for (i in 1:(nAtrib)){
columnas=c(columnas,paste("A",i,sep=""))
}
offset<-c(1:longitud)
df <- data.frame(x=rep(NA, 1),  # as many cols as you need
stringsAsFactors=FALSE)
for (i in 0:(longitud-1)){
bin=as.binary(i,n=nAtrib)
df[i+1, ] <- toString(bin)
}
df <-df %>% separate(x, columnas,sep=",")
###ahora el offset
df<-cbind(offset = offset, df)
##### y la decision (bastante parecido a atributos)
decisiones=i:nDecis
tramo=as.integer(longitud/nDecis)
decisiones=c()
n=length(as.binary(nDecis))
for (i in 1:(nDecis-1)){
dec=as.binary(i-1,n=n)
decisiones=c(decisiones,rep(toString(dec),tramo))
}
#print(decisiones)
dec=as.binary(nDecis-1,n=n)
decisiones=c(decisiones,rep(toString(dec),longitud-tramo*(nDecis-1)))
print(decisiones)
#creamos las columnas de decision
columnasD=c()
for (i in 1:(n)){
columnasD=c(columnasD,paste("D",i,sep=""))
}
df['D']=decisiones
df <-df %>% separate(D, columnasD,sep=",")
return (df)
}
ds<-createCKBM(3,2)
View(ds)
ds<-createCKBM(3,4)
View(ds)
library(binaryLogic)
library(dplyr)
library(tidyr)
createCKBM <-function(nAtrib,nDecis){
### primero los atributos
longitud=2^nAtrib
columnas=c()
for (i in 1:(nAtrib)){
columnas=c(columnas,paste("A",i,sep=""))
}
offset<-c(1:longitud)
df <- data.frame(x=rep(NA, 1),  # as many cols as you need
stringsAsFactors=FALSE)
for (i in 0:(longitud-1)){
bin=as.binary(i,n=nAtrib)
df[i+1, ] <- toString(bin)
}
df <-df %>% separate(x, columnas,sep=",")
###ahora el offset
df<-cbind(offset = offset, df)
##### y la decision (bastante parecido a atributos)
decisiones=i:nDecis
tramo=as.integer(longitud/nDecis)
decisiones=c()
n=length(as.binary(nDecis))
for (i in 1:(nDecis-1)){
dec=as.binary(i-1,n=n)
decisiones=c(decisiones,rep(toString(dec),tramo))
}
#print(decisiones)
dec=as.binary(nDecis-1,n=n)
decisiones=c(decisiones,rep(toString(dec),longitud-tramo*(nDecis-1)))
#print(decisiones)
#creamos las columnas de decision
columnasD=c()
for (i in 1:(n)){
columnasD=c(columnasD,paste("D",i,sep=""))
}
df['D']=decisiones
df <-df %>% separate(D, columnasD,sep=",")
return (df)
}
ds<-createCKBM(3,4)
ds<-createCKBM(3,5)
View(ds)
ds<-createCKBM(7,5)
View(ds)
ds<-createCKBM(4,4)
View(ds)
setwd("C:/Users/rafat/Desktop/Temporal/KBMR-dev")
###   ###
## kbmR ##
###   ###
# source("kbmR-prj.R")
rm(list=ls(all=TRUE))
library( gmp) # bigz
#library( gat)
library( lattice)
library( foreach)
library( cluster)
#### module ####
setwd("./defs")
source("kbmr-definition.R")
setwd("..")
#### module ####
setwd("./tabs")
source("kbmr-inout.R")
#source("kbmr-spectrum.R")
setwd("..")
#### module ####
setwd("./optalg")
source("kbmr-optimization.R")
setwd("..")
#### module ####
setwd("./query")
#source("kbmr-queries.R")
#source("kbmr-explanation.R")
setwd("..")
#### module RAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ####
setwd("./Rafa")
source("custom.base.R")
source("vector.swap.R")
source("combinaciones.base.R")
source("getBestSwap.R")
source("vns.rafa.R")
setwd("..")
### models, kbmr.demo()
setwd("./models")
cat("Models source reading:\n")
#source("kbmr-demo1.R")
#source("kbmr-demo2.R")
#source("kbmr-examples1.R")
#source("kbmr-examples2.R")
#source("kbmr-examples3.R")
#source("kbmr-examples4.R")
#source("kbmr-examples5.R")
#source("kbmr-examples6.R")
#source("kbmr-examples7.R")
cat("Models source OK.\n")
setwd("..")
inst.kbm <- random.kbm( rl=c("D1","D2"), rcl=c(2,2), al=c("A1","A2","A3","A4","A5"), acl=c(2,3,4,5,6), n=20)
print(inst.kbm, MODE="O")
y <- random.base(inst.kbm)
View(y)
z <- swap.base.kbm(x = inst.kbm, new.x = y)
View(z)
View(y)
View(z)
print(z, MODE="O")
base=c(0,1,2,3,4)
b=length(base)
for (it2 in (it1+1):(b)){
print("aqui")
print(it1)
print(it2)
}}
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
print("aqui")
print(it1)
print(it2)
}}
a<-vns.rafa(z)
getBestSwap<-function(rafakbm, proporcion=0.9){
items=length.kbm(rafakbm)
print("empieza")
print(items)
bestbase=rafakbm@base
######### esta lista tiene que tener elementos que contengan tuplas ( la base y el numero de items)
listaBases<-list()
listaItems<-c()
j<-1
b<-length(bestbase)
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
g2= (it1-1)+(it2-it1-1)+2-1
if(g2>(length(b)-1)*proporcion & g2<= (length(b)-1)*(proporcion+0.2)){
# base2=base.swap(base,it1,it2)
# newKBM=kbm.custom.swap(rafakbm,base2)
# items2<-calculate.len.kbm(rafakbm)
newBase<-vector.swap.R(base,it1,it2)
prueba<-custom.base(rafakbm, newBase+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
#print(items2)
if(items2<items){
#lista.add("base"=base2, "items"=items2)
listaBases[[j]]<-newBase
listaItems[[j]]<-items2
}
#g=g+1
}
#h=h+1
}
}
## si hay mejoras, cogemos la mejor
if(length(listaItems)>0){
#bestbase=base(mindist(lista))
bestbase<-listaBases[which.min(listasPos)]
}
return (bestbase)
}
a<-vns.rafa(z)
a
getBestSwap<-function(rafakbm, proporcion=0.9){
items=length.kbm(rafakbm)
print("empieza")
print(items)
bestbase=rafakbm@base
######### esta lista tiene que tener elementos que contengan tuplas ( la base y el numero de items)
listaBases<-list()
listaItems<-c()
j<-1
b<-length(bestbase)
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
g2= (it1-1)+(it2-it1-1)+2-1
print (it1)
print(it2)
if(g2>(length(b)-1)*proporcion & g2<= (length(b)-1)*(proporcion+0.2)){
# base2=base.swap(base,it1,it2)
# newKBM=kbm.custom.swap(rafakbm,base2)
# items2<-calculate.len.kbm(rafakbm)
newBase<-vector.swap.R(base,it1,it2)
prueba<-custom.base(rafakbm, newBase+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
#print(items2)
if(items2<items){
#lista.add("base"=base2, "items"=items2)
listaBases[[j]]<-newBase
listaItems[[j]]<-items2
}
#g=g+1
}
#h=h+1
}
}
## si hay mejoras, cogemos la mejor
if(length(listaItems)>0){
#bestbase=base(mindist(lista))
bestbase<-listaBases[which.min(listasPos)]
}
return (bestbase)
}
a<-vns.rafa(z)
z
a
View(inst.kbm)
View(z)
View(inst.kbm)
View(z)
View(y)
length.kbm(z)
length.kbm(inst.kbm)
getBestSwap<-function(rafakbm, proporcion=0.9){
items=length.kbm(rafakbm)
print("empieza")
print(items)
bestbase=rafakbm@base
######### esta lista tiene que tener elementos que contengan tuplas ( la base y el numero de items)
listaBases<-list()
listaItems<-c()
j<-1
b<-length(bestbase)
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
g2= (it1-1)+(it2-it1-1)+2-1
#print (it1)
#print(it2)
if(g2>(length(b)-1)*proporcion & g2<= (length(b)-1)*(proporcion+0.2)){
# base2=base.swap(base,it1,it2)
# newKBM=kbm.custom.swap(rafakbm,base2)
# items2<-calculate.len.kbm(rafakbm)
newBase<-vector.swap.R(base,it1,it2)
prueba<-custom.base(rafakbm, newBase+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
print(items2)
if(items2<items){
#lista.add("base"=base2, "items"=items2)
listaBases[[j]]<-newBase
listaItems[[j]]<-items2
}
#g=g+1
}
#h=h+1
}
}
## si hay mejoras, cogemos la mejor
if(length(listaItems)>0){
#bestbase=base(mindist(lista))
bestbase<-listaBases[which.min(listasPos)]
}
return (bestbase)
}
a<-vns.rafa(z)
y <- random.base(inst.kbm)
z <- swap.base.kbm(x = inst.kbm, new.x = y)
length.kbm(z)
z <- swap.base.kbm(x = inst.kbm, new.x = y)
a<-vns.rafa(z)
getBestSwap<-function(rafakbm, proporcion=0.9){
items=length.kbm(rafakbm)
print("empieza")
print(items)
bestbase=rafakbm@base
######### esta lista tiene que tener elementos que contengan tuplas ( la base y el numero de items)
listaBases<-list()
listaItems<-c()
j<-1
b<-length(bestbase)
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
g2= (it1-1)+(it2-it1-1)+2-1
#print (it1)
#print(it2)
if(g2>(length(b)-1)*proporcion & g2<= (length(b)-1)*(proporcion+0.2)){
# base2=base.swap(base,it1,it2)
# newKBM=kbm.custom.swap(rafakbm,base2)
# items2<-calculate.len.kbm(rafakbm)
newBase<-vector.swap.R(base,it1,it2)
prueba<-custom.base(rafakbm, newBase+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
print(newBase)
if(items2<items){
#lista.add("base"=base2, "items"=items2)
listaBases[[j]]<-newBase
listaItems[[j]]<-items2
}
#g=g+1
}
#h=h+1
}
}
## si hay mejoras, cogemos la mejor
if(length(listaItems)>0){
#bestbase=base(mindist(lista))
bestbase<-listaBases[which.min(listasPos)]
}
return (bestbase)
}
a<-vns.rafa(z)
getBestSwap<-function(rafakbm, proporcion=0.9){
items=length.kbm(rafakbm)
print("empieza")
print(items)
bestbase=rafakbm@base
######### esta lista tiene que tener elementos que contengan tuplas ( la base y el numero de items)
listaBases<-list()
listaItems<-c()
j<-1
b<-length(bestbase)
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
g2= (it1-1)+(it2-it1-1)+2-1
#print (it1)
#print(it2)
if(g2>(length(b)-1)*proporcion & g2<= (length(b)-1)*(proporcion+0.2)){
# base2=base.swap(base,it1,it2)
# newKBM=kbm.custom.swap(rafakbm,base2)
# items2<-calculate.len.kbm(rafakbm)
newBase<-vector.swap.R(base,it1,it2)
prueba<-custom.base(rafakbm, newBase+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
print(newBase)
if(items2<items){
#lista.add("base"=base2, "items"=items2)
listaBases[[j]]<-newBase
listaItems[[j]]<-items2
}
#g=g+1
}
#h=h+1
}
}
## si hay mejoras, cogemos la mejor
if(length(listaItems)>0){
#bestbase=base(mindist(lista))
bestbase<-listaBases[which.min(listasPos)]
}
return (bestbase)
}
a<-vns.rafa(z)
getBestSwap<-function(rafakbm, proporcion=0.9){
items=length.kbm(rafakbm)
print("empieza")
#print(items)
bestbase=rafakbm@base
######### esta lista tiene que tener elementos que contengan tuplas ( la base y el numero de items)
listaBases<-list()
listaItems<-c()
j<-1
b<-length(bestbase)
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
g2= (it1-1)+(it2-it1-1)+2-1
#print (it1)
print(g2)
if(g2>(length(b)-1)*proporcion & g2<= (length(b)-1)*(proporcion+0.2)){
# base2=base.swap(base,it1,it2)
# newKBM=kbm.custom.swap(rafakbm,base2)
# items2<-calculate.len.kbm(rafakbm)
newBase<-vector.swap.R(base,it1,it2)
prueba<-custom.base(rafakbm, newBase+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
print(newBase)
if(items2<items){
#lista.add("base"=base2, "items"=items2)
listaBases[[j]]<-newBase
listaItems[[j]]<-items2
}
#g=g+1
}
#h=h+1
}
}
## si hay mejoras, cogemos la mejor
if(length(listaItems)>0){
#bestbase=base(mindist(lista))
bestbase<-listaBases[which.min(listasPos)]
}
return (bestbase)
}
a<-vns.rafa(z)
getBestSwap<-function(rafakbm, proporcion=0.9){
items=length.kbm(rafakbm)
print("empieza")
#print(items)
bestbase=rafakbm@base
######### esta lista tiene que tener elementos que contengan tuplas ( la base y el numero de items)
listaBases<-list()
listaItems<-c()
j<-1
b<-length(bestbase)
for(it1 in 1:((b)-1)){
for (it2 in (it1+1):(b)){
g2= (it1-1)+(it2-it1-1)+2-1
#print (it1)
print(g2)
if(g2>((b)-1)*proporcion & g2<= ((b)-1)*(proporcion+0.2)){
# base2=base.swap(base,it1,it2)
# newKBM=kbm.custom.swap(rafakbm,base2)
# items2<-calculate.len.kbm(rafakbm)
newBase<-vector.swap.R(base,it1,it2)
prueba<-custom.base(rafakbm, newBase+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
print(newBase)
if(items2<items){
#lista.add("base"=base2, "items"=items2)
listaBases[[j]]<-newBase
listaItems[[j]]<-items2
}
#g=g+1
}
#h=h+1
}
}
## si hay mejoras, cogemos la mejor
if(length(listaItems)>0){
#bestbase=base(mindist(lista))
bestbase<-listaBases[which.min(listasPos)]
}
return (bestbase)
}
a<-vns.rafa(z)
#funcion que cambia dos elementos de un vector
vector.swap<-function(vector,it1,it2){
vector2<-vector
back<-vector[it1]
vector2[it1]=vector[it2]
vector2[it2]=back
return(vector2)
}
a<-vns.rafa(z)
#funcion que cambia dos elementos de un vector
vector.swap<-function(vector,it1,it2){
vector2<-vector
back<-vector[it1]
vector2[it1]=vector[it2]
vector2[it2]=back
return(vector2)
}
a<-vns.rafa(z)
vns.rafa<-function(rafa.kbm,proporcion=0.8){
for (i in 1:50){
base=rafa.kbm@base
bestBase=getBestSwap(rafa.kbm, proporcion)
##si no mejora, reducimos vecindario
if(all(bestBase==base)){
proporcion=proporcion-0.2
}
#si mejora, volvemos a vecindario grande
else{
base=bestBase
proporcion=0.8
}
if (proporcion<0){
break
}
}
return(base)
}
a<-vns.rafa(z)
source("vector.swap.R")
#### module RAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ####
setwd("./Rafa")
source("vector.swap.R")
a<-vns.rafa(z)
