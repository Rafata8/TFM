setwd("D:/Informatica/TFM/KBMR-dev/Rafa")
rm(list=ls(all=TRUE))
library( gmp) # bigz
#library( gat)
library( lattice)
library( foreach)
library( cluster)
#### module ####
setwd("./defs")
source("kbmr-definition.R")
setwd("..")
#### module ####
setwd("./tabs")
ls
getwd()
#source("kbmr-spectrum.R")
setwd("..")
#### module ####
setwd("./defs")
source("kbmr-definition.R")
setwd("..")
#### module ####
setwd("./tabs")
source("kbmr-inout.R")
#source("kbmr-spectrum.R")
setwd("..")
#### module ####
setwd("./optalg")
source("kbmr-optimization.R")
setwd("..")
#### module ####
setwd("./query")
#source("kbmr-queries.R")
#source("kbmr-explanation.R")
setwd("..")
#### module RAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ####
setwd("./Rafa")
source("custom.base.R")
source("vector.swap.R")
source("combinaciones.base.R")
source("getBestSwap.R")
source("vns.rafa.R")
setwd("..")
### models, kbmr.demo()
setwd("./models")
cat("Models source reading:\n")
cat("Models source OK.\n")
setwd("..")
inst.kbm <- random.kbm( rl=c("D1","D2"), rcl=c(2,2), al=c("A1","A2","A3","A4","A5","A6","A7"), acl=c(2,2,2,2,2,2,2), n=8)
print(inst.kbm, MODE="O")
y<-random.base(inst.kbm)
#prueba<-swap.base.kbm(inst.kbm,y)
a<-swap.base.kbm(x = inst.kbm, new.x = y)
#prueba<-custom.base(inst.kbm,y@base+1)
print(a, MODE="O")
sol<-vns.rafa(a)
print(sol, MODE="O")
sample(5)
################# prueba aneealingggggg
inst.kbm <- random.kbm( rl=c("D1","D2"), rcl=c(2,2), al=c("A1","A2","A3","A4","A5","A6","A7"), acl=c(2,2,2,2,2,2,2), n=8)
combinaciones<-combinaciones.base(inst.kbm@base)
source("vector.swap.R")
getwd()
#### module RAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ####
setwd("./Rafa")
source("vector.swap.R")
##devuelve todas las combinaciones de distancia hamming 2, y devuelve tambien la distancia G
combinaciones.base<- function(base,orden=1,distanciaH=2){
lbas<-length(base)
j<-1
listaBases<-list()
listaDisG<-c()
if(orden==1){
for(it1 in 1:(lbas-1)){
for(it2 in (it1+1):(lbas)){
listaBases[[j]]<-vector.swap(base,it1,it2)
#dis G= Rleft +(sum(huecos entre medias+hamming -1))= (i-1)+(j-i-1)+2-1
#listaDisG[[j]]<- (it1-1)+(it2-it1-1)+2-1
listaDisG<-c(listaDisG,(it1-1)+(it2-it1-1)+2-1)
j<-j+1
}
}
}
else{
for(it1 in lbas:2){
for(it2 in (it1-1):1){
listaBases[[j]]<-vector.swap(base,it1,it2)
#dis G= Rleft +(sum(huecos entre medias+hamming -1))= (i-1)+(j-i-1)+2-1
listaDisG[[j]]<- (it1-1)+(it1-it2-1)+2-1
j<-j+1
}
}
}
result<-list("bases"= listaBases, "distanciaG"= listaDisG)
return(result)
}
combinaciones<-combinaciones.base(inst.kbm@base)
bases<-combinaciones.base
bases
bases<-combinaciones$base
bases[0]
bases[[0]]
bases
bases[[1]]
azara<-sample(bases, 1)
azara
azara<-sample(bases, 1)
azara
x1 <- runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
runif(1, 0, 1)
simulated_annealing <- function(rafakbm,nIter){
bestbase=rafakbm@base
bestkbm<-rafakbm
items=length.kbm(rafakbm)
for (i in 1:nIter){
temp <- temperature( (i+1)/nIter )
# cogemos combinacion al azar
combinaciones<-combinaciones.base(bestbase)
bases<-combinaciones$base
newBase<-sample(bases, 1)
#y lo hacemos kbm y comparamos numero de items
prueba<-custom.base(rafakbm, newBase)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
# si es menor, lo cambiamos
if(items2<items){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
#si es peor, hay probabilidad de cambiarlo
else{
prob<-e^(-(items2-items)/temp)
if(prob>=runif(1, 0, 1)){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
}
}
return(bestkbm)
}
print(inst.kbm, MODE="O")
simulado<-simulated_annealing(inst.kbm,50)
simulated_annealing <- function(rafakbm,nIter,temperature=400){
bestbase=rafakbm@base
bestkbm<-rafakbm
items=length.kbm(rafakbm)
for (i in 1:nIter){
temp <- temperature/nIter
# cogemos combinacion al azar
combinaciones<-combinaciones.base(bestbase)
bases<-combinaciones$base
newBase<-sample(bases, 1)
#y lo hacemos kbm y comparamos numero de items
prueba<-custom.base(rafakbm, newBase)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
# si es menor, lo cambiamos
if(items2<items){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
#si es peor, hay probabilidad de cambiarlo
else{
prob<-e^(-(items2-items)/temp)
if(prob>=runif(1, 0, 1)){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
}
}
return(bestkbm)
}
simulado<-simulated_annealing(inst.kbm,50)
simulado<-simulated_annealing(inst.kbm,50)
simulated_annealing <- function(rafakbm,nIter,temperature=400){
bestbase=rafakbm@base
bestkbm<-rafakbm
items=length.kbm(rafakbm)
for (i in 1:nIter){
temp <- temperature/nIter
# cogemos combinacion al azar
combinaciones<-combinaciones.base(bestbase)
bases<-combinaciones$base
newBase<-sample(bases, 1)+1
#y lo hacemos kbm y comparamos numero de items
prueba<-custom.base(rafakbm, newBase)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
# si es menor, lo cambiamos
if(items2<items){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
#si es peor, hay probabilidad de cambiarlo
else{
prob<-e^(-(items2-items)/temp)
if(prob>=runif(1, 0, 1)){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
}
}
return(bestkbm)
}
simulado<-simulated_annealing(inst.kbm,50)
simulated_annealing <- function(rafakbm,nIter,temperature=400){
bestbase=rafakbm@base
bestkbm<-rafakbm
items=length.kbm(rafakbm)
for (i in 1:nIter){
temp <- temperature/nIter
# cogemos combinacion al azar
combinaciones<-combinaciones.base(bestbase)
bases<-combinaciones$base
newBase<-sample(bases, 1)
#y lo hacemos kbm y comparamos numero de items
prueba<-custom.base(rafakbm, (newBase+1))
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
# si es menor, lo cambiamos
if(items2<items){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
#si es peor, hay probabilidad de cambiarlo
else{
prob<-e^(-(items2-items)/temp)
if(prob>=runif(1, 0, 1)){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
}
}
return(bestkbm)
}
simulado<-simulated_annealing(inst.kbm,50)
simulated_annealing <- function(rafakbm,nIter,temperature=400){
bestbase=rafakbm@base
bestkbm<-rafakbm
items=length.kbm(rafakbm)
for (i in 1:nIter){
temp <- temperature/nIter
# cogemos combinacion al azar
combinaciones<-combinaciones.base(bestbase)
bases<-combinaciones$base
newBase<-sample(bases, 1)
#y lo hacemos kbm y comparamos numero de items
prueba<-custom.base(rafakbm, (newBase)+1)
prueba<-swap.base.kbm(rafakbm,prueba)
items2<-length.kbm(prueba)
# si es menor, lo cambiamos
if(items2<items){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
#si es peor, hay probabilidad de cambiarlo
else{
prob<-e^(-(items2-items)/temp)
if(prob>=runif(1, 0, 1)){
bestkbm<-prueba
items<-items2
bestbase<-newBase
}
}
}
return(bestkbm)
}
simulado<-simulated_annealing(inst.kbm,50)
